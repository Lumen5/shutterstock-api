# coding: utf-8

"""
    Shutterstock API Reference

    The Shutterstock API provides access to Shutterstock's library of media, as well as information about customers' accounts and the contributors that provide the media.  # noqa: E501

    OpenAPI spec version: 1.0.6
    
    Generated by: https://github.com/swagger-api/swagger-codegen.git
"""


from __future__ import absolute_import

import re  # noqa: F401

# python 2 and python 3 compatibility library
import six

from shutterstock_api.api_client import ApiClient


class VideosApi(object):
    """NOTE: This class is auto generated by the swagger code generator program.

    Do not edit the class manually.
    Ref: https://github.com/swagger-api/swagger-codegen
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient()
        self.api_client = api_client

    def add_clipbox_items(self, id, body, **kwargs):  # noqa: E501
        """Add videos to collections  # noqa: E501

        This endpoint adds one or more videos to a collection by video IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_clipbox_items(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to which items should be added (required)
        :param CollectionItemRequest body: Array of video IDs to add to the collection (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.add_clipbox_items_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.add_clipbox_items_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def add_clipbox_items_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Add videos to collections  # noqa: E501

        This endpoint adds one or more videos to a collection by video IDs.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.add_clipbox_items_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to which items should be added (required)
        :param CollectionItemRequest body: Array of video IDs to add to the collection (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method add_clipbox_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `add_clipbox_items`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `add_clipbox_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections/{id}/items', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def create_clipbox(self, body, **kwargs):  # noqa: E501
        """Create video collections  # noqa: E501

        This endpoint creates one or more collections (clipboxes). To add videos to collections, use `POST /videos/collections/{id}/items`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_clipbox(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CollectionCreateRequest body: Collection metadata (required)
        :return: CollectionCreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.create_clipbox_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.create_clipbox_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def create_clipbox_with_http_info(self, body, **kwargs):  # noqa: E501
        """Create video collections  # noqa: E501

        This endpoint creates one or more collections (clipboxes). To add videos to collections, use `POST /videos/collections/{id}/items`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.create_clipbox_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param CollectionCreateRequest body: Collection metadata (required)
        :return: CollectionCreateResponse
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method create_clipbox" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `create_clipbox`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CollectionCreateResponse',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_clipbox(self, id, **kwargs):  # noqa: E501
        """Delete video collections  # noqa: E501

        This endpoint deletes a collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_clipbox(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_clipbox_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_clipbox_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_clipbox_with_http_info(self, id, **kwargs):  # noqa: E501
        """Delete video collections  # noqa: E501

        This endpoint deletes a collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_clipbox_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to delete (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_clipbox" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_clipbox`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections/{id}', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def delete_clipbox_items(self, id, **kwargs):  # noqa: E501
        """Remove videos from collections  # noqa: E501

        This endpoint removes one or more videos from a collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_clipbox_items(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the Collection from which items will be deleted (required)
        :param list[str] item_id: One or more video IDs to remove from the collection
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.delete_clipbox_items_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.delete_clipbox_items_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def delete_clipbox_items_with_http_info(self, id, **kwargs):  # noqa: E501
        """Remove videos from collections  # noqa: E501

        This endpoint removes one or more videos from a collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.delete_clipbox_items_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the Collection from which items will be deleted (required)
        :param list[str] item_id: One or more video IDs to remove from the collection
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'item_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method delete_clipbox_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `delete_clipbox_items`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'item_id' in params:
            query_params.append(('item_id', params['item_id']))  # noqa: E501
            collection_formats['item_id'] = 'multi'  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections/{id}/items', 'DELETE',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def download_videos(self, id, body, **kwargs):  # noqa: E501
        """Download videos  # noqa: E501

        This endpoint redownloads videos that you have already received a license for.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_videos(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The license ID of the item to (re)download (required)
        :param RedownloadVideo body: Information about the videos to redownload (required)
        :return: Url
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.download_videos_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.download_videos_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def download_videos_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Download videos  # noqa: E501

        This endpoint redownloads videos that you have already received a license for.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.download_videos_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The license ID of the item to (re)download (required)
        :param RedownloadVideo body: Information about the videos to redownload (required)
        :return: Url
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method download_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `download_videos`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `download_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/licenses/{id}/downloads', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Url',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_clipbox(self, id, **kwargs):  # noqa: E501
        """Get the details of video collections  # noqa: E501

        This endpoint gets more detailed information about a collection, including the timestamp for its creation and the number of videos in it. To get the videos in collections, use GET /videos/collections/{id}/items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clipbox(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to return (required)
        :return: Collection
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_clipbox_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_clipbox_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_clipbox_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the details of video collections  # noqa: E501

        This endpoint gets more detailed information about a collection, including the timestamp for its creation and the number of videos in it. To get the videos in collections, use GET /videos/collections/{id}/items.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clipbox_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to return (required)
        :return: Collection
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clipbox" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_clipbox`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Collection',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_clipbox_items(self, id, **kwargs):  # noqa: E501
        """Get the contents of video collections  # noqa: E501

        This endpoint lists the IDs of videos in a collection and the date that each was added.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clipbox_items(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the Collection whose items are to be returned (required)
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str sort: Sort order
        :return: CollectionItemDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_clipbox_items_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_clipbox_items_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_clipbox_items_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get the contents of video collections  # noqa: E501

        This endpoint lists the IDs of videos in a collection and the date that each was added.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clipbox_items_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the Collection whose items are to be returned (required)
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str sort: Sort order
        :return: CollectionItemDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'per_page', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clipbox_items" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_clipbox_items`")  # noqa: E501

        if 'page' in params and params['page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_clipbox_items`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'per_page' in params and params['per_page'] > 150:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_clipbox_items`, must be a value less than or equal to `150`")  # noqa: E501
        if 'per_page' in params and params['per_page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_clipbox_items`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections/{id}/items', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CollectionItemDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_clipbox_list(self, **kwargs):  # noqa: E501
        """List video collections  # noqa: E501

        This endpoint lists your collections of videos and their basic attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clipbox_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number
        :param int per_page: Number of results per page
        :return: CollectionDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_clipbox_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_clipbox_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_clipbox_list_with_http_info(self, **kwargs):  # noqa: E501
        """List video collections  # noqa: E501

        This endpoint lists your collections of videos and their basic attributes.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_clipbox_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param int page: Page number
        :param int per_page: Number of results per page
        :return: CollectionDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['page', 'per_page']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_clipbox_list" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_clipbox_list`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'per_page' in params and params['per_page'] > 150:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_clipbox_list`, must be a value less than or equal to `150`")  # noqa: E501
        if 'per_page' in params and params['per_page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_clipbox_list`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CollectionDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_similar_videos(self, id, **kwargs):  # noqa: E501
        """List similar videos  # noqa: E501

        This endpoint searches for videos that are similar to a video that you specify.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_similar_videos(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of a video for which similar videos should be returned (required)
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str view: Amount of detail to render in the response
        :return: VideoSearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_similar_videos_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_similar_videos_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_similar_videos_with_http_info(self, id, **kwargs):  # noqa: E501
        """List similar videos  # noqa: E501

        This endpoint searches for videos that are similar to a video that you specify.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_similar_videos_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of a video for which similar videos should be returned (required)
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str view: Amount of detail to render in the response
        :return: VideoSearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'page', 'per_page', 'view']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_similar_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_similar_videos`")  # noqa: E501

        if 'page' in params and params['page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_similar_videos`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'per_page' in params and params['per_page'] > 500:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_similar_videos`, must be a value less than or equal to `500`")  # noqa: E501
        if 'per_page' in params and params['per_page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_similar_videos`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/{id}/similar', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VideoSearchResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_updated_videos(self, **kwargs):  # noqa: E501
        """List updated videos  # noqa: E501

        This endpoint lists videos that have been updated in the specified time period to update content management systems (CMS) or digital asset management (DAM) systems. In most cases, use the `interval` parameter to show videos that were updated recently, but you can also use the `start_date` and `end_date` parameters to specify a range of no more than three days. Do not use the `interval` parameter with either `start_date` or `end_date`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_updated_videos(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date start_date: Show videos updated on or after the specified date, in the format YYYY-MM-DD
        :param date end_date: Show videos updated before the specified date, in the format YYYY-MM-DD
        :param str interval: Show videos updated in the specified time period, where the time period is an interval (like SQL INTERVAL) such as 1 DAY, 6 HOUR, or 30 MINUTE; the default is 1 HOUR, which shows videos that were updated in the hour preceding the request
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str sort: Sort by oldest or newest videos first
        :return: UpdatedMediaDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_updated_videos_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_updated_videos_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_updated_videos_with_http_info(self, **kwargs):  # noqa: E501
        """List updated videos  # noqa: E501

        This endpoint lists videos that have been updated in the specified time period to update content management systems (CMS) or digital asset management (DAM) systems. In most cases, use the `interval` parameter to show videos that were updated recently, but you can also use the `start_date` and `end_date` parameters to specify a range of no more than three days. Do not use the `interval` parameter with either `start_date` or `end_date`.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_updated_videos_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date start_date: Show videos updated on or after the specified date, in the format YYYY-MM-DD
        :param date end_date: Show videos updated before the specified date, in the format YYYY-MM-DD
        :param str interval: Show videos updated in the specified time period, where the time period is an interval (like SQL INTERVAL) such as 1 DAY, 6 HOUR, or 30 MINUTE; the default is 1 HOUR, which shows videos that were updated in the hour preceding the request
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str sort: Sort by oldest or newest videos first
        :return: UpdatedMediaDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['start_date', 'end_date', 'interval', 'page', 'per_page', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_updated_videos" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_updated_videos`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'per_page' in params and params['per_page'] > 2000:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_updated_videos`, must be a value less than or equal to `2000`")  # noqa: E501
        if 'per_page' in params and params['per_page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_updated_videos`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'start_date' in params:
            query_params.append(('start_date', params['start_date']))  # noqa: E501
        if 'end_date' in params:
            query_params.append(('end_date', params['end_date']))  # noqa: E501
        if 'interval' in params:
            query_params.append(('interval', params['interval']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/updated', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='UpdatedMediaDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_video(self, id, **kwargs):  # noqa: E501
        """Get details about videos  # noqa: E501

        This endpoint shows information about a video, including URLs to previews and the sizes that it is available in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Video ID (required)
        :param str view: Amount of detail to render in the response
        :return: Video
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_video_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_video_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_video_with_http_info(self, id, **kwargs):  # noqa: E501
        """Get details about videos  # noqa: E501

        This endpoint shows information about a video, including URLs to previews and the sizes that it is available in.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: Video ID (required)
        :param str view: Amount of detail to render in the response
        :return: Video
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'view']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_video" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_video`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/{id}', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='Video',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_video_categories(self, **kwargs):  # noqa: E501
        """List video categories  # noqa: E501

        This endpoint lists the categories (Shutterstock-assigned genres) that videos can belong to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_categories(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CategoryDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_video_categories_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_video_categories_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_video_categories_with_http_info(self, **kwargs):  # noqa: E501
        """List video categories  # noqa: E501

        This endpoint lists the categories (Shutterstock-assigned genres) that videos can belong to.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_categories_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :return: CategoryDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = []  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_video_categories" % key
                )
            params[key] = val
        del params['kwargs']

        collection_formats = {}

        path_params = {}

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/categories', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='CategoryDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_video_license_list(self, **kwargs):  # noqa: E501
        """List video licenses  # noqa: E501

        This endpoint lists existing licenses. You can filter the results according to the type of license or the video ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_license_list(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str video_id: Show licenses for the specified video ID
        :param str license: Show videos that are available with the specified license, such as `standard` or `enhanced`; prepending a `-` sign excludes results from that license
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str sort: Sort by oldest or newest videos first
        :return: DownloadHistoryDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_video_license_list_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.get_video_license_list_with_http_info(**kwargs)  # noqa: E501
            return data

    def get_video_license_list_with_http_info(self, **kwargs):  # noqa: E501
        """List video licenses  # noqa: E501

        This endpoint lists existing licenses. You can filter the results according to the type of license or the video ID.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_license_list_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str video_id: Show licenses for the specified video ID
        :param str license: Show videos that are available with the specified license, such as `standard` or `enhanced`; prepending a `-` sign excludes results from that license
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str sort: Sort by oldest or newest videos first
        :return: DownloadHistoryDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['video_id', 'license', 'page', 'per_page', 'sort']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_video_license_list" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `get_video_license_list`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'per_page' in params and params['per_page'] > 200:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_video_license_list`, must be a value less than or equal to `200`")  # noqa: E501
        if 'per_page' in params and params['per_page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `get_video_license_list`, must be a value greater than or equal to `1`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'video_id' in params:
            query_params.append(('video_id', params['video_id']))  # noqa: E501
        if 'license' in params:
            query_params.append(('license', params['license']))  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/licenses', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='DownloadHistoryDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def get_video_list(self, id, **kwargs):  # noqa: E501
        """List videos  # noqa: E501

        This endpoint lists information about one or more videos, including the aspect ratio and URLs to previews.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_list(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] id: One or more video IDs (required)
        :param str view: Amount of detail to render in the response
        :return: VideoDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.get_video_list_with_http_info(id, **kwargs)  # noqa: E501
        else:
            (data) = self.get_video_list_with_http_info(id, **kwargs)  # noqa: E501
            return data

    def get_video_list_with_http_info(self, id, **kwargs):  # noqa: E501
        """List videos  # noqa: E501

        This endpoint lists information about one or more videos, including the aspect ratio and URLs to previews.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.get_video_list_with_http_info(id, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param list[str] id: One or more video IDs (required)
        :param str view: Amount of detail to render in the response
        :return: VideoDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'view']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method get_video_list" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `get_video_list`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'id' in params:
            query_params.append(('id', params['id']))  # noqa: E501
            collection_formats['id'] = 'multi'  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VideoDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def license_videos(self, body, **kwargs):  # noqa: E501
        """License videos  # noqa: E501

        This endpoint gets licenses for one or more videos. You must specify the video IDs in the body parameter and the size and subscription ID either in the query parameter or with each video ID in the body parameter. Values in the body parameter override values in the query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.license_videos(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LicenseVideoRequest body: List of videos to request licenses for and information about each license transaction; these values override the defaults in the query parameters (required)
        :param str subscription_id: The subscription ID to use for licensing
        :param str size: The size of the video to license
        :param str search_id: The Search ID that led to this licensing event
        :return: LicenseVideoResultDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.license_videos_with_http_info(body, **kwargs)  # noqa: E501
        else:
            (data) = self.license_videos_with_http_info(body, **kwargs)  # noqa: E501
            return data

    def license_videos_with_http_info(self, body, **kwargs):  # noqa: E501
        """License videos  # noqa: E501

        This endpoint gets licenses for one or more videos. You must specify the video IDs in the body parameter and the size and subscription ID either in the query parameter or with each video ID in the body parameter. Values in the body parameter override values in the query parameters.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.license_videos_with_http_info(body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param LicenseVideoRequest body: List of videos to request licenses for and information about each license transaction; these values override the defaults in the query parameters (required)
        :param str subscription_id: The subscription ID to use for licensing
        :param str size: The size of the video to license
        :param str search_id: The Search ID that led to this licensing event
        :return: LicenseVideoResultDataList
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['body', 'subscription_id', 'size', 'search_id']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method license_videos" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `license_videos`")  # noqa: E501

        collection_formats = {}

        path_params = {}

        query_params = []
        if 'subscription_id' in params:
            query_params.append(('subscription_id', params['subscription_id']))  # noqa: E501
        if 'size' in params:
            query_params.append(('size', params['size']))  # noqa: E501
        if 'search_id' in params:
            query_params.append(('search_id', params['search_id']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/licenses', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='LicenseVideoResultDataList',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def rename_clipbox(self, id, body, **kwargs):  # noqa: E501
        """Rename video collections  # noqa: E501

        This endpoint sets a new name for a collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_clipbox(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to rename (required)
        :param CollectionUpdateRequest body: The new name for the collection (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.rename_clipbox_with_http_info(id, body, **kwargs)  # noqa: E501
        else:
            (data) = self.rename_clipbox_with_http_info(id, body, **kwargs)  # noqa: E501
            return data

    def rename_clipbox_with_http_info(self, id, body, **kwargs):  # noqa: E501
        """Rename video collections  # noqa: E501

        This endpoint sets a new name for a collection.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.rename_clipbox_with_http_info(id, body, async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param str id: The ID of the collection to rename (required)
        :param CollectionUpdateRequest body: The new name for the collection (required)
        :return: None
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['id', 'body']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method rename_clipbox" % key
                )
            params[key] = val
        del params['kwargs']
        # verify the required parameter 'id' is set
        if ('id' not in params or
                params['id'] is None):
            raise ValueError("Missing the required parameter `id` when calling `rename_clipbox`")  # noqa: E501
        # verify the required parameter 'body' is set
        if ('body' not in params or
                params['body'] is None):
            raise ValueError("Missing the required parameter `body` when calling `rename_clipbox`")  # noqa: E501

        collection_formats = {}

        path_params = {}
        if 'id' in params:
            path_params['id'] = params['id']  # noqa: E501

        query_params = []

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        if 'body' in params:
            body_params = params['body']
        # HTTP header `Content-Type`
        header_params['Content-Type'] = self.api_client.select_header_content_type(  # noqa: E501
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/collections/{id}', 'POST',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type=None,  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)

    def search_videos(self, **kwargs):  # noqa: E501
        """Search for videos  # noqa: E501

        This endpoint searches for videos. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter. You can also filter search terms out in the `query` parameter by prefixing the term with NOT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_videos(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date added_date: Show videos added on the specified date, in the format YYYY-MM-DD
        :param date added_date_start: Show videos added on or after the specified date, in the format YYYY-MM-DD
        :param date added_date_end: Show videos added before the specified date, in the format YYYY-MM-DD
        :param str aspect_ratio: Show videos with the specified aspect ratio
        :param str category: Show videos with the specified Shutterstock-defined category; specify a category name or ID
        :param list[str] contributor: Show videos with the specified artist names or IDs
        :param int duration: (Deprecated; use duration_from and duration_to instead) Show videos with the specified duration (seconds)
        :param int duration_from: Show videos with the specified duration or longer (seconds)
        :param int duration_to: Show videos with the specified duration or shorter (seconds)
        :param float fps: (Deprecated; use fps_from and fps_to instead) Show videos with the specified frames per second
        :param float fps_from: Show videos with the specified frames per second or more
        :param float fps_to: Show videos with the specified frames per second or fewer
        :param str language: Set query and result language (uses Accept-Language header if not set)
        :param list[str] license: Show only videos with the specified license or licenses
        :param list[str] model: Show videos with each of the specified models
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str people_age: Show videos that feature people of the specified age range
        :param str people_ethnicity: Show videos with people of the specified ethnicity
        :param str people_gender: Show videos with people with the specified gender
        :param int people_number: Show videos with the specified number of people
        :param bool people_model_released: Show only videos of people with a signed model release
        :param str query: One or more search terms separated by spaces; you can use NOT to filter out videos that match a term
        :param str resolution: Show videos with the specified resolution
        :param bool safe: Enable or disable safe search
        :param str sort: Sort by one of these categories
        :param str view: Amount of detail to render in the response
        :return: VideoSearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """
        kwargs['_return_http_data_only'] = True
        if kwargs.get('async_req'):
            return self.search_videos_with_http_info(**kwargs)  # noqa: E501
        else:
            (data) = self.search_videos_with_http_info(**kwargs)  # noqa: E501
            return data

    def search_videos_with_http_info(self, **kwargs):  # noqa: E501
        """Search for videos  # noqa: E501

        This endpoint searches for videos. If you specify more than one search parameter, the API uses an AND condition. Array parameters can be specified multiple times; in this case, the API uses an AND or an OR condition with those values, depending on the parameter. You can also filter search terms out in the `query` parameter by prefixing the term with NOT.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True
        >>> thread = api.search_videos_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req bool
        :param date added_date: Show videos added on the specified date, in the format YYYY-MM-DD
        :param date added_date_start: Show videos added on or after the specified date, in the format YYYY-MM-DD
        :param date added_date_end: Show videos added before the specified date, in the format YYYY-MM-DD
        :param str aspect_ratio: Show videos with the specified aspect ratio
        :param str category: Show videos with the specified Shutterstock-defined category; specify a category name or ID
        :param list[str] contributor: Show videos with the specified artist names or IDs
        :param int duration: (Deprecated; use duration_from and duration_to instead) Show videos with the specified duration (seconds)
        :param int duration_from: Show videos with the specified duration or longer (seconds)
        :param int duration_to: Show videos with the specified duration or shorter (seconds)
        :param float fps: (Deprecated; use fps_from and fps_to instead) Show videos with the specified frames per second
        :param float fps_from: Show videos with the specified frames per second or more
        :param float fps_to: Show videos with the specified frames per second or fewer
        :param str language: Set query and result language (uses Accept-Language header if not set)
        :param list[str] license: Show only videos with the specified license or licenses
        :param list[str] model: Show videos with each of the specified models
        :param int page: Page number
        :param int per_page: Number of results per page
        :param str people_age: Show videos that feature people of the specified age range
        :param str people_ethnicity: Show videos with people of the specified ethnicity
        :param str people_gender: Show videos with people with the specified gender
        :param int people_number: Show videos with the specified number of people
        :param bool people_model_released: Show only videos of people with a signed model release
        :param str query: One or more search terms separated by spaces; you can use NOT to filter out videos that match a term
        :param str resolution: Show videos with the specified resolution
        :param bool safe: Enable or disable safe search
        :param str sort: Sort by one of these categories
        :param str view: Amount of detail to render in the response
        :return: VideoSearchResults
                 If the method is called asynchronously,
                 returns the request thread.
        """

        all_params = ['added_date', 'added_date_start', 'added_date_end', 'aspect_ratio', 'category', 'contributor', 'duration', 'duration_from', 'duration_to', 'fps', 'fps_from', 'fps_to', 'language', 'license', 'model', 'page', 'per_page', 'people_age', 'people_ethnicity', 'people_gender', 'people_number', 'people_model_released', 'query', 'resolution', 'safe', 'sort', 'view']  # noqa: E501
        all_params.append('async_req')
        all_params.append('_return_http_data_only')
        all_params.append('_preload_content')
        all_params.append('_request_timeout')

        params = locals()
        for key, val in six.iteritems(params['kwargs']):
            if key not in all_params:
                raise TypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method search_videos" % key
                )
            params[key] = val
        del params['kwargs']

        if 'page' in params and params['page'] < 1:  # noqa: E501
            raise ValueError("Invalid value for parameter `page` when calling `search_videos`, must be a value greater than or equal to `1`")  # noqa: E501
        if 'per_page' in params and params['per_page'] > 500:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `search_videos`, must be a value less than or equal to `500`")  # noqa: E501
        if 'per_page' in params and params['per_page'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `per_page` when calling `search_videos`, must be a value greater than or equal to `0`")  # noqa: E501
        if 'people_number' in params and params['people_number'] > 4:  # noqa: E501
            raise ValueError("Invalid value for parameter `people_number` when calling `search_videos`, must be a value less than or equal to `4`")  # noqa: E501
        if 'people_number' in params and params['people_number'] < 0:  # noqa: E501
            raise ValueError("Invalid value for parameter `people_number` when calling `search_videos`, must be a value greater than or equal to `0`")  # noqa: E501
        collection_formats = {}

        path_params = {}

        query_params = []
        if 'added_date' in params:
            query_params.append(('added_date', params['added_date']))  # noqa: E501
        if 'added_date_start' in params:
            query_params.append(('added_date_start', params['added_date_start']))  # noqa: E501
        if 'added_date_end' in params:
            query_params.append(('added_date_end', params['added_date_end']))  # noqa: E501
        if 'aspect_ratio' in params:
            query_params.append(('aspect_ratio', params['aspect_ratio']))  # noqa: E501
        if 'category' in params:
            query_params.append(('category', params['category']))  # noqa: E501
        if 'contributor' in params:
            query_params.append(('contributor', params['contributor']))  # noqa: E501
            collection_formats['contributor'] = 'multi'  # noqa: E501
        if 'duration' in params:
            query_params.append(('duration', params['duration']))  # noqa: E501
        if 'duration_from' in params:
            query_params.append(('duration_from', params['duration_from']))  # noqa: E501
        if 'duration_to' in params:
            query_params.append(('duration_to', params['duration_to']))  # noqa: E501
        if 'fps' in params:
            query_params.append(('fps', params['fps']))  # noqa: E501
        if 'fps_from' in params:
            query_params.append(('fps_from', params['fps_from']))  # noqa: E501
        if 'fps_to' in params:
            query_params.append(('fps_to', params['fps_to']))  # noqa: E501
        if 'language' in params:
            query_params.append(('language', params['language']))  # noqa: E501
        if 'license' in params:
            query_params.append(('license', params['license']))  # noqa: E501
            collection_formats['license'] = 'multi'  # noqa: E501
        if 'model' in params:
            query_params.append(('model', params['model']))  # noqa: E501
            collection_formats['model'] = 'multi'  # noqa: E501
        if 'page' in params:
            query_params.append(('page', params['page']))  # noqa: E501
        if 'per_page' in params:
            query_params.append(('per_page', params['per_page']))  # noqa: E501
        if 'people_age' in params:
            query_params.append(('people_age', params['people_age']))  # noqa: E501
        if 'people_ethnicity' in params:
            query_params.append(('people_ethnicity', params['people_ethnicity']))  # noqa: E501
        if 'people_gender' in params:
            query_params.append(('people_gender', params['people_gender']))  # noqa: E501
        if 'people_number' in params:
            query_params.append(('people_number', params['people_number']))  # noqa: E501
        if 'people_model_released' in params:
            query_params.append(('people_model_released', params['people_model_released']))  # noqa: E501
        if 'query' in params:
            query_params.append(('query', params['query']))  # noqa: E501
        if 'resolution' in params:
            query_params.append(('resolution', params['resolution']))  # noqa: E501
        if 'safe' in params:
            query_params.append(('safe', params['safe']))  # noqa: E501
        if 'sort' in params:
            query_params.append(('sort', params['sort']))  # noqa: E501
        if 'view' in params:
            query_params.append(('view', params['view']))  # noqa: E501

        header_params = {}

        form_params = []
        local_var_files = {}

        body_params = None
        # HTTP header `Accept`
        header_params['Accept'] = self.api_client.select_header_accept(
            ['application/json'])  # noqa: E501

        # Authentication setting
        auth_settings = ['basic', 'customer_accessCode']  # noqa: E501

        return self.api_client.call_api(
            '/v2/videos/search', 'GET',
            path_params,
            query_params,
            header_params,
            body=body_params,
            post_params=form_params,
            files=local_var_files,
            response_type='VideoSearchResults',  # noqa: E501
            auth_settings=auth_settings,
            async_req=params.get('async_req'),
            _return_http_data_only=params.get('_return_http_data_only'),
            _preload_content=params.get('_preload_content', True),
            _request_timeout=params.get('_request_timeout'),
            collection_formats=collection_formats)
